<h1 align=center>
ğŸ“˜ Term 1 â€” Foundations ğŸ“˜
</h1>

<p align=center>
<strong>Date Range: </strong> 
April 1, 2024 â€“ September 30, 2024
<br>
<strong>Total Competency Units: </strong>
12
</p>

<h2 align=center>
ğŸ§­ Term Overview
</h2>

Term 1 established the technical baseline required to transition into software engineering. While this phase contained limited programming, it built the environmental awareness necessary to understand how software actually runs, communications, and persists data.

This term focused on **systems literacy before software construction**.

Rather than writing applications, the emphasis was on understanding:
- How operating systems manage execution
- How networks move data between systems
- How relational databases structure information
- How to communicate technical ideas clearly.

These concepts now inform every development decision I make. 

<h2 align=center>
ğŸ› ï¸ Competencies Developed
</h2>

### System Awareness
Understanding how software interacts with hardware, memory, and process scheduling.

### Networking Fundamentals
Learning how data transmission, addressing, and security concepts underpin APIs and distributed systems.

### Data Modeling Foundations
Building a mental model for relational databases, normalization, and structured query behavior.

### Technical Communication
Explaining ideas in structured, professional documentation â€” an essential engineering skill often overlooked in early learning

<h2 align=center>
ğŸ“š Courses Completed This Term
</h2>

<div align=center>

| Order | Code | Course Name | Focus Area |
|-------|------|-------------|------------|
| 01 | D339 | Technical Communication | Writing, documentation, and structured explanation |
| 02 | D426 | Data Management â€“ Foundations | Relational theory and SQL fundamentals |
| 03 | D386 | Hardware & Operating Systems Essentials | System architecture and execution context |
| 04 | D315 | Network & Security - Foundations | Connectivity, protocols, and security concepts | 

</div> 


<h2 align="center">
ğŸš€ Explore Each Course
</h2>

<p align="center">
    <a href="/term-01-foundations/01-d339-technical-communication/">
        <img src="https://img.shields.io/badge/OPEN-D339%20Technical%20Communication-2ea44f?style=for-the-badge" />
    </a>
    <br>
    <a href="/term-01-foundations/02-d426-data-management-foundations/">
        <img src="https://img.shields.io/badge/OPEN-D426%20Data%20Management-0366d6?style=for-the-badge" />
    </a>
    <br>
    <a href="/term-01-foundations/03-d386-hardware-os/">
        <img src="https://img.shields.io/badge/OPEN-D386%20Hardware%20%26%20OS-8250df?style=for-the-badge" />
    </a>
    <br>
    <a href="/term-01-foundations/04-d315-network-security/">
        <img src="https://img.shields.io/badge/OPEN-D315%20Network%20%26%20Security-d73a49?style=for-the-badge" />
    </a>
</p>


<h2 align=center>
ğŸ§  Retrospective
</h2>

At the time, these courses felt disconnected from software development because they were not immediately tied to building applications. Combined with several information-dense subjects delivered back-to-back, maintaining momentum required a higher-level of self-direction than I initially anticipated.

This created periods where progress felt abstract rather than tangible, which made sustaining motivation more challenging. Additionally, like many assessment=heavy environments, I found that testing anxiety occasionally impacted my pacing, requiring me to develop better preparation and review strategies rather than relying on short-term memorization.

Despite those challenges, in hindsight, these corses provided the context that makes later engineering decisions meaningful.

Understanding:
- why latency exists, 
- how processes are scheduled, 
- why schema design matters,
- and how environments are configured

...prevents treating software as something that runs in isolation.

These fundamentals shifted my mindset from focusing on writing code to understand the systems that code must operate within.

<h2 align=center>
ğŸ” What I Would Do Differently
</h2>

If I were structuring this learning path again, I would interleave one or two application-focused or programming-heavy courses alongside these foundational topics. Introducing hands-on development earlier would have created a stronger feedback loop between theory and implementation, reinforcing both.

I would also place greater emphasis on iterative review and practical reinforcement to mitigate test-related pressure â€” focusing on long-term comprehension rather than preparing solely for individual assessments.

<h2 align=center>
ğŸš€ How This Term Influences My Work Now
</h2>

This foundation directly impacts how I approach back-end and full-stack work today:
- Designing applications with deployment environments in mind
- Structuring databases intentionally rather than reactively
- Understanding performance as a system concern, not just code quality
- Reading documentation first instead of relying on trial-and-error

Term 1 shifted my mindset from **"writing code"** to **"building software that lives inside systems."**